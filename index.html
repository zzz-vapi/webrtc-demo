<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Local WebRTC Chat</title>
    <style>
        body {
            background: #222;
            color: #f9f9f9;
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #log {
            border: 1px solid #444;
            padding: 10px;
            margin-top: 10px;
            height: 300px;
            overflow-y: auto;
            background: #333;
            color: #f9f9f9;
            display: flex;
            flex-direction: column;
        }
        .log-message {
            margin-bottom: 5px;
        }
        #inputContainer {
            margin-top: auto;
            display: flex;
            align-items: center;
        }
        #textInput {
            flex: 1;
            padding: 8px;
            margin-right: 4px;
            background: #444;
            color: #f9f9f9;
            border: 1px solid #555;
        }
        button {
            padding: 8px;
            background: #555;
            color: #f9f9f9;
            border: 1px solid #666;
            cursor: pointer;
        }
        .audio-container {
            margin: 10px 0;
            padding: 8px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #volumeSlider {
            width: 100px;
            accent-color: #555;
        }
        #muteButton {
            padding: 4px 8px;
            margin-right: 8px;
            background: #444;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }
        .status {
            margin: 10px 0;
            padding: 8px;
            border-radius: 4px;
            background: #444;
        }
        .status.connected {
            background: #2a5;
        }
        .status.disconnected {
            background: #a52;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        #startButton {
            background: #2a5;
        }
        #endButton {
            background: #a52;
            display: none;
        }
        #startSpeakButton {
            background: #2a5;
        }
        #endSpeakButton {
            background: #a52;
            display: none;
        }
        #settingsButton {
            background: #555;
        }
        .input-control {
            margin-top: 10px;
        }
        #audioInput {
            padding: 8px;
            background: #444;
            color: #f9f9f9;
            border: 1px solid #555;
        }
    </style>
</head>
<body>
    <h1>Local WebRTC Chat</h1>
    <p>Click below to start/end a session with the local WebRTC server.</p>

    <div id="status" class="status disconnected">Disconnected</div>
    <div class="button-group">
        <button id="startButton">ðŸŸ¢ Start Session</button>
        <button id="startSpeakButton">ðŸŽ¤ Start Speak</button>
    </div>

    <div class="audio-container">
        <audio id="remoteAudio" autoplay></audio>
        <div class="volume-control">
            <label for="volumeSlider">Remote Audio Control: </label>
            <button id="muteButton">ðŸ”Š</button>
        <input
          type="range"
          id="volumeSlider"
          min="0"
          max="1"
          step="0.1"
          value="1"
        />
        </div>
        <div class="input-control">
            <label for="audioInput">Microphone: </label>
            <select id="audioInput"></select>
        </div>
    </div>

    <div id="log">
        <div id="inputContainer">
        <input
          id="textInput"
          type="text"
          placeholder="Type your message here"
        />
            <button id="sendButton">Send</button>
        </div>
    </div>

    <div class="warning">
        This site uses a self-signed certificate for development purposes.
        You may need to accept the security warning in your browser.
    </div>

    <script>
        // WebRTC globals
      let pc; // RTCPeerConnection
      let track; // Local audio track
      let localStream; // Local media stream
      let isCallActive = false; // Call state
      let isSpeaking = false; // Speaking state
        let speakDebounceTimer = null; // Debounce timer for speak button
      let dataChannel; // Data channel for control messages

        // DOM elements
      const remoteAudioEl = document.getElementById("remoteAudio");
      const muteButton = document.getElementById("muteButton");
      const volumeSlider = document.getElementById("volumeSlider");
        const logEl = document.getElementById("log");
        const inputContainerEl = document.getElementById("inputContainer");
        const textInputEl = document.getElementById("textInput");
        const sendButtonEl = document.getElementById("sendButton");
        const statusEl = document.getElementById("status");
        const startButtonEl = document.getElementById("startButton");
        const endButtonEl = document.getElementById("endButton");
        const startSpeakButtonEl = document.getElementById("startSpeakButton");
        const endSpeakButtonEl = document.getElementById("endSpeakButton");
        const settingsButtonEl = document.getElementById("settingsButton");
      const audioInputEl = document.getElementById("audioInput");

      // Get the base URL from the current window location
      const baseURL = window.location.origin;

      // Initialize WebRTC connection
      async function getICEServers() {
        try {
          const response = await fetch("/ice-servers", {
            method: "GET",
            credentials: "same-origin",
            headers: {
              "Content-Type": "application/json",
            },
          });

          if (!response.ok) {
            throw new Error("Failed to get ICE servers");
          }

          const config = await response.json();
          return config.iceServers;
        } catch (error) {
          console.error("Error fetching ICE servers");
          throw error;
        }
      }

      async function initWebRTC() {
        try {
          const config = {
            iceServers: [{
              urls: 'stun:stun.l.google.com:19302'
            }]
          };

          pc = new RTCPeerConnection(config);

          // Add the hardcoded candidate immediately after creating the connection
          const hardcodedCandidate = new RTCIceCandidate({
            candidate: 'candidate:1 1 udp 2122260223 54.244.51.77 3478 typ host generation 0 network-id 1 network-cost 10',
            sdpMid: '0',
            sdpMLineIndex: 0
          });

          console.log("Adding hardcoded host candidate:", hardcodedCandidate);
          await pc.addIceCandidate(hardcodedCandidate);

          // Set up ICE candidate handler
          pc.onicecandidate = async (event) => {
            if (event.candidate) {
              console.log("New ICE candidate:", event.candidate.candidate);
              
              // Create array with hardcoded candidate first
              const candidates = [
                hardcodedCandidate.toJSON(),
                event.candidate.toJSON()
              ];

              try {
                await fetch(`${window.location.origin}/ice-candidates`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({ candidates }),
                });
              } catch (err) {
                console.error("Error sending candidates:", err);
              }
            } else {
              console.log("ICE candidate gathering completed");
            }
          };

          // Log ICE connection state changes
          pc.oniceconnectionstatechange = () => {
            console.log("ICE Connection State:", pc.iceConnectionState);
            appendLog("ICE Connection State: " + pc.iceConnectionState);
            if (pc.iceConnectionState === "failed") {
              console.log("ICE connection failed - checking candidates");
              appendLog("ICE connection failed - checking candidates");
              // Log current candidates
              pc.currentRemoteDescription?.sdp.split("\n").forEach((line) => {
                if (line.startsWith("a=candidate:")) {
                  console.log("Remote candidate:", line);
                  appendLog("Remote candidate: " + line);
                }
              });
            }
          };

          // Log ICE gathering state changes
          pc.onicegatheringstatechange = () => {
            console.log("ICE Gathering State:", pc.iceGatheringState);
            appendLog("ICE Gathering State: " + pc.iceGatheringState);
            if (pc.iceGatheringState === "complete") {
              console.log("ICE gathering completed - checking candidates");
              appendLog("ICE gathering completed - checking candidates");
              // Log current candidates
              pc.currentLocalDescription?.sdp.split("\n").forEach((line) => {
                if (line.startsWith("a=candidate:")) {
                  console.log("Local candidate:", line);
                  appendLog("Local candidate: " + line);
                }
              });
            }
          };

          // Handle incoming tracks
          pc.ontrack = (event) => {
            console.log("Received remote track:", event.track.kind);
            appendLog("Received remote track: " + event.track.kind);

            // Set up audio element
            if (event.track.kind === "audio") {
              remoteAudioEl.srcObject = event.streams[0];
              remoteAudioEl.play().catch((err) => {
                console.error("Error playing audio:", err);
                appendLog("Error playing audio: " + err.message);
              });
            }
          };

          // Create data channel for control messages
          console.log("Creating data channel");
          dataChannel = pc.createDataChannel("control", {
            ordered: true,
            maxRetransmits: 3,
          });

          // Set up data channel handlers BEFORE creating the offer
          dataChannel.onopen = () => {
            console.log("Data channel opened");
            appendLog("Control channel opened");
            startSpeakButtonEl.disabled = false;
          };

          dataChannel.onclose = () => {
            console.log("Data channel closed");
            appendLog("Control channel closed");
            startSpeakButtonEl.disabled = true;
          };

          dataChannel.onerror = (error) => {
            console.error("Data channel error:", error);
            appendLog("Control channel error: " + error.message);
          };

          dataChannel.onmessage = (event) => {
            console.log("Received message:", event.data);
            appendLog("Server: " + event.data);
          };

          // Set up connection state handler BEFORE creating the offer
          pc.onconnectionstatechange = () => {
            console.log("Connection state changed:", pc.connectionState);
            appendLog("Connection state: " + pc.connectionState);
            if (pc.connectionState === "failed") {
              console.log("Connection failed - checking ICE candidates");
              appendLog("Connection failed - checking ICE candidates");
              // Log all current candidates
              pc.currentRemoteDescription?.sdp.split("\n").forEach((line) => {
                if (line.startsWith("a=candidate:")) {
                  console.log("Remote candidate:", line);
                  appendLog("Remote candidate: " + line);
                }
              });
              pc.currentLocalDescription?.sdp.split("\n").forEach((line) => {
                if (line.startsWith("a=candidate:")) {
                  console.log("Local candidate:", line);
                  appendLog("Local candidate: " + line);
                }
              });
            }
          };

                // Get local audio stream with selected device
                const selectedDeviceId = audioInputEl.value;
                console.log("Selected audio device ID:", selectedDeviceId);
                
                const constraints = {
                    audio: {
              deviceId: selectedDeviceId
                ? { exact: selectedDeviceId }
                : undefined,
                        echoCancellation: true,
                        noiseSuppression: true,
              autoGainControl: true,
            },
                };
                console.log("Audio constraints:", constraints);
                
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                [track] = localStream.getAudioTracks();
                console.log("Local audio track created:", {
                    kind: track.kind,
                    id: track.id,
                    enabled: track.enabled,
                    muted: track.muted,
                    label: track.label,
            deviceId: track.getSettings().deviceId,
                });

                // Add local track before creating offer
                const sender = pc.addTrack(track, localStream);
          console.log(
            "Added track sender:",
            sender.track?.kind,
            sender.track?.id
          );

          // Create and send offer
          console.log("Creating offer");
                const offer = await pc.createOffer({
                    offerToReceiveAudio: true,
            offerToReceiveVideo: false,
          });
          await pc.setLocalDescription(offer);

          try {
            console.log("Sending offer to server");
            const response = await fetch(`${baseURL}/offer`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                sdp: pc.localDescription.sdp,
              }),
            });

            if (!response.ok) {
              throw new Error("Failed to send offer");
            }

            const answer = await response.json();
            console.log("Received answer from server");
            await pc.setRemoteDescription(answer);

            // Wait for ICE gathering to complete
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error("Timeout waiting for ICE gathering"));
              }, 5000); // 5 second timeout

              const checkGathering = () => {
                if (pc.iceGatheringState === "complete") {
                  clearTimeout(timeout);
                  resolve();
                } else {
                  setTimeout(checkGathering, 100);
                }
              };
              checkGathering();
            });

            console.log("ICE gathering completed");
            appendLog("ICE gathering completed");

            // Get all candidates from the local description
            const candidates = [];
            pc.currentLocalDescription?.sdp.split("\n").forEach((line) => {
              if (line.startsWith("a=candidate:")) {
                console.log("Final local candidate:", line);
                appendLog("Final local candidate: " + line);
                candidates.push(line);
              }
            });

            // Send all candidates to the server
            try {
              console.log("Sending ICE candidates to server");
              const candidateResponse = await fetch(`${baseURL}/ice-candidates`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  candidates: candidates,
                }),
              });
              if (!candidateResponse.ok) {
                throw new Error("Failed to send ICE candidates");
              }
              console.log("All ICE candidates sent successfully");
              appendLog("All ICE candidates sent successfully");

              // Wait for connection to be established
              await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                  reject(new Error("Timeout waiting for connection"));
                }, 15000); // Increase to 15 seconds

                const checkConnection = () => {
                  if (pc.connectionState === "connected") {
                    clearTimeout(timeout);
                    resolve();
                  } else if (pc.connectionState === "failed") {
                    clearTimeout(timeout);
                    reject(new Error("Connection failed"));
                  } else {
                    // Log the current state for debugging
                    console.log("Current connection state:", pc.connectionState);
                    console.log("Current ICE connection state:", pc.iceConnectionState);
                    setTimeout(checkConnection, 500); // Check every 500ms
                  }
                };
                checkConnection();
              });

              console.log("Connection established");
              appendLog("Connection established");

              // Now wait for data channel to be ready
              await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                  reject(new Error("Timeout waiting for data channel"));
                }, 15000); // Increase to 15 seconds

                const checkChannel = () => {
                  if (dataChannel && dataChannel.readyState === "open") {
                    clearTimeout(timeout);
                    resolve();
                  } else if (dataChannel && dataChannel.readyState === "closed") {
                    clearTimeout(timeout);
                    reject(new Error("Data channel closed"));
                  } else {
                    // Log the current state for debugging
                    console.log("Data channel state:", dataChannel ? dataChannel.readyState : "not created");
                    setTimeout(checkChannel, 500); // Check every 500ms
                  }
                };
                checkChannel();
              });

              console.log("Data channel is ready");
              appendLog("Data channel is ready");
            } catch (err) {
              console.error("Error during connection setup:", err);
              throw err;
            }
          } catch (err) {
            console.error("Error during offer/answer exchange:", err);
            throw err;
          }

          console.log("WebRTC connection established");
          appendLog("WebRTC connection established");
                startButtonEl.disabled = false;
          updateStatus(true);
        } catch (error) {
          console.error("Failed to initialize WebRTC");
        }
        }

        // Start speak
        async function startSpeak() {
            try {
                // Prevent duplicate events
                if (isSpeaking) {
                    console.log("Already speaking, ignoring start speak");
                    return;
                }

          // Wait for data channel to be ready with timeout
          if (!dataChannel || dataChannel.readyState !== "open") {
            console.log("Waiting for data channel to be ready...");
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                reject(new Error("Timeout waiting for data channel"));
              }, 5000); // 5 second timeout

              const checkChannel = () => {
                if (dataChannel && dataChannel.readyState === "open") {
                  clearTimeout(timeout);
                  resolve();
                } else {
                  setTimeout(checkChannel, 100);
                }
              };
              checkChannel();
            });
          }

          // Send start speak message through data channel
          dataChannel.send(JSON.stringify({ type: "start_speak" }));
          console.log("Sent start_speak message");

                isSpeaking = true;
                isCallActive = true;
                toggleSpeakButtons(true);
                appendLog("Started speaking");
            } catch (err) {
                console.error("Error starting speak:", err);
                appendLog("Error starting speak: " + err.message);
                isSpeaking = false;
                isCallActive = false;
                toggleSpeakButtons(false);
            }
        }

        // End speak
        async function endSpeak() {
            try {
                // Prevent duplicate events
                if (!isSpeaking) {
                    console.log("Not speaking, ignoring end speak");
                    return;
                }

          // Wait for data channel to be ready
          if (!dataChannel || dataChannel.readyState !== "open") {
            console.log("Waiting for data channel to be ready...");
            await new Promise((resolve) => {
              const checkChannel = () => {
                if (dataChannel && dataChannel.readyState === "open") {
                  resolve();
                } else {
                  setTimeout(checkChannel, 100);
                }
              };
              checkChannel();
            });
          }

          // Send end speak message through data channel
          dataChannel.send(JSON.stringify({ type: "end_speak" }));
          console.log("Sent end_speak message");

                isSpeaking = false;
                isCallActive = false;
                toggleSpeakButtons(false);
                appendLog("Ended speaking");
            } catch (err) {
                console.error("Error ending speak:", err);
                appendLog("Error ending speak: " + err.message);
                isSpeaking = false;
                isCallActive = false;
                toggleSpeakButtons(false);
            }
        }

        // End session
        async function endSession() {
            if (isSpeaking) {
                await endSpeak();
            }
        if (dataChannel) {
          dataChannel.close();
            }
            if (pc) {
                pc.close();
            }
            isSpeaking = false;
            isCallActive = false;
            toggleSessionButtons(false);
            updateStatus(false);
            appendLog("Session ended");
        }

        // Send message through data channel
        function sendMessage() {
            const text = textInputEl.value.trim();
        if (text && dataChannel && dataChannel.readyState === "open") {
          dataChannel.send(text);
                appendLog("You: " + text);
                textInputEl.value = "";
            }
        }

      // UI helpers
      function toggleSessionButtons(isSessionActive) {
        // Toggle between Start/End Session button
        if (isSessionActive) {
          startButtonEl.textContent = "ðŸ”´ End Session";
          startButtonEl.disabled = false;
        } else {
          startButtonEl.textContent = "ðŸŸ¢ Start Session";
          startButtonEl.disabled = false;
        }
      }

      function toggleSpeakButtons(isSpeaking) {
        // Toggle between Start/End Speak button
        if (isSpeaking) {
          startSpeakButtonEl.textContent = "â¹ï¸ End Speak";
          startSpeakButtonEl.disabled = false; // Ensure button is enabled when speaking
        } else {
          startSpeakButtonEl.textContent = "ðŸŽ¤ Start Speak";
          startSpeakButtonEl.disabled = false; // Ensure button is enabled when not speaking
        }
      }

      function updateStatus(connected) {
        statusEl.textContent = connected ? "Connected" : "Disconnected";
        statusEl.className = `status ${
          connected ? "connected" : "disconnected"
        }`;
        // Only disable the speak button if we're not connected
        if (!connected) {
          startSpeakButtonEl.disabled = true;
        }
      }

      // Append message to log
      function appendLog(message) {
        const logEntry = document.createElement("div");
        logEntry.textContent = message;
        logEntry.classList.add("log-message");
        logEl.insertBefore(logEntry, inputContainerEl);
        logEl.scrollTop = logEl.scrollHeight;
      }

      // Get available audio input devices
      async function getAudioInputs() {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const audioInputs = devices.filter(
            (device) => device.kind === "audioinput"
          );

          console.log(
            "Available audio input devices:",
            audioInputs.map((d) => ({
              id: d.deviceId,
              label: d.label,
              kind: d.kind,
            }))
          );

          // Clear existing options
          audioInputEl.innerHTML = "";

          // Add options for each audio input
          audioInputs.forEach((device) => {
            const option = document.createElement("option");
            option.value = device.deviceId;
            option.text =
              device.label || `Microphone ${audioInputEl.length + 1}`;
            audioInputEl.appendChild(option);
            console.log("Added audio input option:", {
              id: device.deviceId,
              label: device.label,
              kind: device.kind,
            });
          });

          // If no devices are available yet, request permissions
          if (audioInputs.length === 0) {
            console.log("No audio devices found, requesting permissions...");
            await navigator.mediaDevices.getUserMedia({ audio: true });
            // Refresh the list after getting permissions
            getAudioInputs();
          }
        } catch (err) {
          console.error("Error getting audio inputs:", err);
          appendLog("Error getting audio inputs: " + err.message);
        }
      }

        // Event listeners
        startButtonEl.addEventListener("click", async () => {
        try {
          await initWebRTC();
        } catch (err) {
          console.error("Error starting session:", err);
          appendLog("Error starting session: " + err.message);
            }
        });

        // Single event listener for speak button
        startSpeakButtonEl.addEventListener("click", () => {
            if (isSpeaking) {
                endSpeak();
            } else {
                startSpeak();
            }
        });

        sendButtonEl.addEventListener("click", sendMessage);
        textInputEl.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
                sendMessage();
            }
        });

      volumeSlider.addEventListener(
        "input",
        (e) => (remoteAudioEl.volume = e.target.value)
      );
      muteButton.addEventListener("click", () => {
            const isMuted = remoteAudioEl.muted;
            remoteAudioEl.muted = !isMuted;
        muteButton.textContent = isMuted ? "ðŸ”Š" : "ðŸ”‡";
        });

      audioInputEl.addEventListener("change", async () => {
        if (pc?.connectionState === "connected") {
                // If we're already connected, we need to restart the session
                appendLog("Changing audio input requires session restart");
                await endSession();
          await initWebRTC();
            }
        });

      // Initialize audio inputs
        getAudioInputs();

      if (window.location.protocol !== 'https:') {
          alert('Please use HTTPS for WebRTC functionality');
          window.location.href = 'https://' + window.location.host + window.location.pathname;
      }
    </script>
</body>
</html> 
